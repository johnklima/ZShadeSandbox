#include "Scalar.h"
#include <stdlib.h> // For abs() and rand()
using ZShadeSandboxMath::Scalar;
//==================================================================================================================================
//==================================================================================================================================
Scalar::Scalar()
{
}
//==================================================================================================================================
float Scalar::Frac(float n)
{
	float aVal = abs(n);
	return aVal - floor(aVal);
}
//==================================================================================================================================
float Scalar::Wrap(float x, float range)
{
	float t = x / range;
	float ft = Frac(t);
	return range * ft;
}
//==================================================================================================================================
float Scalar::EaseOut(float x)
{
	float a = x - 1;
	return a*a*a + 1;
}
//==================================================================================================================================
float Scalar::EaseOutVel(float x)
{
	float a = x - 1;
	return a*a*3;
}
//==================================================================================================================================
float Scalar::RandBetween(float a, float b)
{
	return rand() * (b - a) + a;
}
//==================================================================================================================================
int Scalar::RandBetweenInt(int a, int b)
{
	return (int)(RandBetween(a, b));
}
//==================================================================================================================================
int Scalar::RandUint()
{
	return (uint32)(rand() * kMaxRandValue);
}
//==================================================================================================================================
int Scalar::RandInt()
{
	return (int)(rand() * kMaxRandValue);
}
//==================================================================================================================================
float Scalar::FromVector2(XMFLOAT2 v)
{
	return atan2(v.y, v.x);
}
//==================================================================================================================================
float Scalar::FromVector3(XMFLOAT3 v)
{
	return atan2(v.y, v.x);
}
//==================================================================================================================================
uint32 Scalar::MakeColor(uint32 r, uint32 g, uint32 b)
{
	return r |( g << 8 )|( b << 16 );
}
//==================================================================================================================================
uint32 Scalar::RedFromColor(uint32 c)
{
	return c & 0xff;
}
//==================================================================================================================================
uint32 Scalar::GreenFromColor(uint32 c)
{
	return (c >> 8) & 0xff;
}
//==================================================================================================================================
uint32 Scalar::BlueFromColor(uint32 c)
{
	return (c >> 16) & 0xff;
}
//==================================================================================================================================
float Scalar::InfinityCurve(float x)
{
	return -1 / (x + 1) + 1;
}
//==================================================================================================================================
float Scalar::RadToDeg(float radians)
{
	return (radians / PI) * 180;
}
//==================================================================================================================================
float Scalar::DegToRad(float degrees)
{
	return (degrees * PI) / 180;
}
//==================================================================================================================================
float Scalar::Clamp(float a, float pmin, float pmax)
{
	a = max( pmin, a );
	a = min( pmax, a );
	
	return a;
}
//==================================================================================================================================
float Scalar::Sign(float a)
{
	return a >= 0 ? 1 : -1;
}
//==================================================================================================================================