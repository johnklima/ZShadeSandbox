
#ifndef _OCEAN_WAVE_H
#define _OCEAN_WAVE_H

#include "D3D.h"
#include "CSFFT/fft_512x512.h"
#include "OceanParameters.h"

//<JPK> seems to me better to keep the heightfield
//within the simulator class, rather than encapsulate.
//it just sort of makes things more complicated.
//#include "OceanHeightfield.h"

//#define CS_DEBUG_BUFFER
#define PAD16(n) (((n)+15)/16*16)

#define FRESNEL_TEX_SIZE  256
#define PERLIN_TEX_SIZE   64

class OceanSimulator
{
public:
   OceanSimulator(OceanParameters& params, ID3D11Device* pd3dDevice);
	~OceanSimulator();

	// -------------------------- Initialization & simulation routines ------------------------

	// Update ocean wave when tick arrives.
	void updateDisplacementMap(float time);

	// Texture access
	ID3D11ShaderResourceView* getD3D11DisplacementMap();
	ID3D11ShaderResourceView* getD3D11GradientMap();

   const OceanParameters& getParameters();

//make everything public for now and then establish what needs encapsulation
public:

   
   OceanParameters m_param;

	// ---------------------------------- GPU shading asset -----------------------------------

	// D3D objects
	ID3D11Device* m_pd3dDevice;
	ID3D11DeviceContext* m_pd3dImmediateContext;
	
	// Displacement map
	ID3D11Texture2D* m_pDisplacementMap;		// (RGBA32F)
	ID3D11ShaderResourceView* m_pDisplacementSRV = NULL;
	ID3D11RenderTargetView* m_pDisplacementRTV;

	// Gradient field
	ID3D11Texture2D* m_pGradientMap;			// (RGBA16F)
	ID3D11ShaderResourceView* m_pGradientSRV = NULL;
	ID3D11RenderTargetView* m_pGradientRTV;

   //Perlin noise
   ID3D11ShaderResourceView* m_pPerlinSRV = NULL;

	// Samplers
	ID3D11SamplerState* m_pPointSamplerState;

   ID3D11Buffer* m_pDebugBuffer;
   ID3D11Buffer* m_pDebugBuffer2;



	// Initialize the vector field.
	void initHeightMap(OceanParameters& params, XMFLOAT2* out_h0, float* out_omega);

   XMFLOAT3 ReadWave(int x, int z);

	// ----------------------------------- CS simulation data ---------------------------------

	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	ID3D11Buffer* m_pBuffer_Float2_H0;
	ID3D11UnorderedAccessView* m_pUAV_H0;
	ID3D11ShaderResourceView* m_pSRV_H0;

	// Angular frequency
	ID3D11Buffer* m_pBuffer_Float_Omega;
	ID3D11UnorderedAccessView* m_pUAV_Omega;
	ID3D11ShaderResourceView* m_pSRV_Omega;

	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	ID3D11Buffer* m_pBuffer_Float2_Ht;
	ID3D11UnorderedAccessView* m_pUAV_Ht;
	ID3D11ShaderResourceView* m_pSRV_Ht;

	// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
	ID3D11Buffer* m_pBuffer_Float_Dxyz;
	ID3D11UnorderedAccessView* m_pUAV_Dxyz;
	ID3D11ShaderResourceView* m_pSRV_Dxyz;

	ID3D11Buffer* m_pQuadVB;

	// Shaders, layouts and constants
	ID3D11ComputeShader* m_pUpdateSpectrumCS;

	ID3D11VertexShader* m_pQuadVS;
	ID3D11PixelShader* m_pUpdateDisplacementPS;
	ID3D11PixelShader* m_pGenGradientFoldingPS;

	ID3D11InputLayout* m_pQuadLayout;

	ID3D11Buffer* m_pImmutableCB;
	ID3D11Buffer* m_pPerFrameCB;

	// FFT wrap-up
	CSFFT512x512_Plan m_fft_plan;

   //buffer to hold displacement map
   XMFLOAT2* v;
   float* h;

#ifdef CS_DEBUG_BUFFER
	ID3D11Buffer* m_pDebugBuffer;
#endif
};

#endif	// _OCEAN_WAVE_H
